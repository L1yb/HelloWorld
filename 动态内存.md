# 动态内存 Dynamic memory

# 动态内存


## 1 动态内存与智能指针

​	new：在动态内存中为对象分配空间并返回一个指向该对象的指针

​	delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存

**新标准库提供两种智能指针：** 和常规指针的区别是能**自动释放所指对象**

 这两者的区别是：

​	**shared_ptr** 允许对各指针指向同一个对象

​	**unique_ptr** 独占所指对象

**weak_ptr**伴随类，弱引用，指向shared_ptr所管理的对象

> 都定义在 memory头文件



### shared_ptr类

#### 创建智能指针

1. 必须指出可以指向的类型
2. 命名 shared_ptr<T> p1;
3. 默认初始化是空指针     

#### 使用

1. 解引用返回所指对象
2. 在判断条件中，检测为空；有指向，则为true
3. p.get() 返回保存的指针，如果释放了其对象，返回的指针中所指的对象消失
4.  swap(p, q)    p.swap(q)  
5. make_shared<T>(args)   返回一个shared_ptr，指向动态分配的类型为T的对象。使用args初始化   //独有
6. shared_ptr<T> p (q)   p是q的拷贝，会**增加q**中的**计数器**   //独有
7. p = q 都是shared，保存的指针能互相转换，会**递减p**的引用计数，若p的引用计数变为0，**将原内存释放** //独有

####  make_shared 最安全的分配使用动态内存方法

定义在memory头文件中

```cpp
	shared_ptr<int> p1 = make_shared<int> (42) //创建值为42的int的shared_ptr
    shared_ptr<string> p2 = make_shared<string> (10,'a') //p2 指向值为42的string
    
```



根据args构造对象，不传参数按照值初始化

**每个shared_ptr都有一个关联计数器，称为 引用计数，只要拷贝一个shared，计数器都会递增，赋予一个新的值或者被销毁（例如离开作用域）会递减，一旦计数器变为0，就会自动释放自己管理的对象**

>  tip：不是指针被释放，是指针所指对象被释放（因为已经不被引用了）



####  shared_ptr自动销毁所管理的对象

​	当指向一个对象的最后一个shared被销毁时，shared类会通过析构函数自动销毁此对象。

#### shared_ptr还会自动释放相关联的内存

​	例如，在函数体内创建并初始化一个智能指针，那么离开函数体，所指向的内存就被释放了。

​	如果，这个shared_ptr作为返回值返回，引用计数递增，那么所指向的内存不会被释放

- **对于一块内存，shared_ptr只有在保证没有任何对象使用它时，才会释放它**

​	note：如果将shared放入一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不在需要的那些元素



#### 使用了动态生存期的资源的类

​	程序使用动态内存的原因：

1. 程序不知道自己需要多少对象 （容器类）
2. 程序不知道所需对象的准确类型
3. 程序需要在多个对象之间共享数据

​	目前为止，我们使用的类分配的资源都与对应对象生存期一致。例如，vector分配的元素只有当这个vector存在时才存在。当vector被销毁时，其中的元素也被销毁。

```cpp
vector<string> v1;
{//new scope
    vector<string> v2 = {"live", "in", "v2"};
    v1 = v2; //v1 copy v2
}// v2 is destroyed, and its elements are alse destoryed.
//v1 have three elements copied from v2
```

​		v2虽然被销毁，但是v1中有这些元素的拷贝。

但是，某些类分配的资源具有与原对象独立的生存期，例如Bolb对象不同拷贝之间共享相同的元素，即, **引用相同的底层元素**

```cpp
Bolb<string> b1;
{//new scope
    Bolb<string> b2 = {"live", "in", "b2"};
    b1 = b2; //b1 and b2 share elements
}// b2 is destoryed,but the elements within b2 are not destoryed
// b1 point to the elements initially created by b2

```

b2 被销毁，但是b1指向了这些元素，b1仍在使用。

​	一般而言，如果两个对象共享底层数据，当某个对象被销毁时，不能单方面销毁底层数据



#### 定义StrBlob类

设计思路：

- 使用标准库容器来管理元素，vector，
- 直接使用vector的话，如果数据存储在其中一个Blob对象b1中，当b1离开作用域，vector将被销毁
  例如：class Blob { vector<T> v1};
- 为了将其数据保存，将vector存在动态内存中，设置一个shared_ptr来管理vector的分配，shared_ptr将记录有多少StrBlob对象共享相同的vector,并在没有使用者时销毁vector
- 提供操作。我们会修改访问这些元素。如果用户试图访问不存在的元素，会抛出一个异常
- 默认构造和构造函数，接受单一initializer_list<string> 参数







### 直接管理内存 new、 delete

在学习拷贝之前，除非使用智能指针来管理内存，否则不要分配动态内存。

















