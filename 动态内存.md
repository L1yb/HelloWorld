# 动态内存 Dynamic memory

# 动态内存


## 一、动态内存与智能指针

​	new：在动态内存中为对象分配空间并返回一个指向该对象的指针

​	delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存

**新标准库提供两种智能指针：** 和常规指针的区别是能**自动释放所指对象**

 这两者的区别是：

​	**shared_ptr** 允许对各指针指向同一个对象

​	**unique_ptr** 独占所指对象

**weak_ptr**伴随类，弱引用，指向shared_ptr所管理的对象

> 都定义在 memory头文件



### 1 shared_ptr类

#### 创建智能指针

1. 必须指出可以指向的类型
2. 命名 shared_ptr<T> p1;
3. 默认初始化是空指针     

#### 使用

1. 解引用返回所指对象
2. 在判断条件中，检测为空；有指向，则为true
3. p.get() 返回保存的指针，如果释放了其对象，返回的指针中所指的对象消失
4.  swap(p, q)    p.swap(q)  
5. make_shared<T>(args)   返回一个shared_ptr，指向动态分配的类型为T的对象。使用args初始化   //独有
6. shared_ptr<T> p (q)   p是q的拷贝，会**增加q**中的**计数器**   //独有
7. p = q 都是shared，保存的指针能互相转换，会**递减p**的引用计数，若p的引用计数变为0，**将原内存释放** //独有

####  make_shared 最安全的分配使用动态内存方法

定义在memory头文件中

```cpp
	shared_ptr<int> p1 = make_shared<int> (42) //创建值为42的int的shared_ptr
    shared_ptr<string> p2 = make_shared<string> (10,'a') //p2 指向值为42的string
    
```

- 传**递的参数必须能够用来初始化，必须初始化**

根据args构造对象，不传参数按照值初始化

**每个shared_ptr都有一个关联计数器，称为 引用计数，只要拷贝一个shared，计数器都会递增，赋予一个新的值或者被销毁（例如离开作用域）会递减，一旦计数器变为0，就会自动释放自己管理的对象**

>  tip：不是指针被释放，是指针所指对象被释放（因为已经不被引用了）



####  shared_ptr自动销毁所管理的对象

​	当指向一个对象的最后一个shared被销毁时，shared类会通过析构函数自动销毁此对象。

#### shared_ptr还会自动释放相关联的内存

​	例如，在函数体内创建并初始化一个智能指针，那么离开函数体，所指向的内存就被释放了。

​	如果，这个shared_ptr作为返回值返回，引用计数递增，那么所指向的内存不会被释放

- **对于一块内存，shared_ptr只有在保证没有任何对象使用它时，才会释放它**

​	note：如果将shared放入一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不在需要的那些元素



#### 使用了动态生存期的资源的类

​	程序使用动态内存的原因：

1. 程序不知道自己需要多少对象 （容器类）
2. 程序不知道所需对象的准确类型
3. 程序需要在多个对象之间共享数据

​	目前为止，我们使用的类分配的资源都与对应对象生存期一致。例如，vector分配的元素只有当这个vector存在时才存在。当vector被销毁时，其中的元素也被销毁。

```cpp
vector<string> v1;
{//new scope
    vector<string> v2 = {"live", "in", "v2"};
    v1 = v2; //v1 copy v2
}// v2 is destroyed, and its elements are alse destoryed.
//v1 have three elements copied from v2
```

​		v2虽然被销毁，但是v1中有这些元素的拷贝。

但是，某些类分配的资源具有与原对象独立的生存期，例如Bolb对象不同拷贝之间共享相同的元素，即, **引用相同的底层元素**

```cpp
Bolb<string> b1;
{//new scope
    Bolb<string> b2 = {"live", "in", "b2"};
    b1 = b2; //b1 and b2 share elements
}// b2 is destoryed,but the elements within b2 are not destoryed
// b1 point to the elements initially created by b2

```

b2 被销毁，但是b1指向了这些元素，b1仍在使用。

​	一般而言，如果两个对象共享底层数据，当某个对象被销毁时，不能单方面销毁底层数据



#### 定义StrBlob类

设计思路：

- 使用标准库容器来管理元素，vector，
- 直接使用vector的话，如果数据存储在其中一个Blob对象b1中，当b1离开作用域，vector将被销毁
  例如：class Blob { vector<T> v1};
- 为了将其数据保存，将vector存在动态内存中，设置一个shared_ptr来管理vector的分配，shared_ptr将记录有多少StrBlob对象共享相同的vector,并在没有使用者时销毁vector
- 提供操作。我们会修改访问这些元素。如果用户试图访问不存在的元素，会抛出一个异常
- 默认构造和构造函数，接受单一initializer_list<string> 参数



#### 小结

在StrBlob类的设计中，提到了

1. 关于设计const版本的问题
   有些函数，本身不会修改成员的信息，可以把他设置成const成员函数，这样的好处是，如果用户创建了const类对象，依然能够有调用成功。
   在课后习题中有个问题，**是否需要const版本的push_back和pop_back(overload)**,这是一个逻辑问题，如果是**const对象，那么意味着它的成员数据是不可修改的**，定义const版本的push和pop函数，虽然能够实现push和pop的功能，和符合编译器的规则，但是违背的const对象本身的逻辑，所以不需要。**但是！如果成员是指针**，push和pop并不修改当前const对象的成员数据，**因为并未改变指向**，**只是修改指针所指的对象**，这么一来，似乎又符合逻辑了。
   关于刚才的思考似乎并没有绝对的对错，只由设计者自己决定，但是我倾向于不设计const的push和pop，既然是const对象，在初始化时定义好之后便不再修改了。（还不会更深入的操作之前就这么搞）



### 2 直接管理内存 new、 delete

在学习拷贝之前，除非使用智能指针来管理内存，否则不要分配动态内存。

new : 分配内存

delete： 释放new分配的内存

tip：容易出错，智能指针更容易调试

#### 使用new动态分配和初始化对象

自由空间分配的内存是无名的，new无法为其命名，而是返回一个指向它的指针。

int *p = new int;

**初始化**

1. 动态分配的对象是**默认初始化**的， 内置类型和组合类型是未定义的，类类型由构造函数决定

2. 可以使用**直接初始化**定义初始值
   ```cpp
   int *p = new int(1024);
   int *str = new string(10,'a');
   vector<int> *pv = new vector<int>{1,2,3,4,5,6,7,8,9};
   ```

3. 也可以**值初始化**,在类型名后加（）即可；
   ```cpp
   int *p0 = new int; //默认初始化，值未定义
   int *p2 = new int(); //值初始化，值为0
   int *str0 = new string; //默认初始化为空
   int *str1 = new string();//值初始化为空
   ```

4. 单一类型初始化器可以使用auto
   ```cpp
   auto *p1 = new auto (obj);//obj是单一类型 
   ```

   

对于有默认构造的类型，默认初始化和值初始化没有区别，都是调用**默认构造函数**；

但是没有默认构造的类型，默认初始化的值是未定义的；

**所以建议都使用值初始化！**



#### 动态分配const对象

const对象必须初始化，new可以为const对象分配内存，分配的对象是const的，new返回的是指向const的指针（point to const）



#### 内存耗尽

如果内存耗尽，会抛出一个错误，bad_alloc。给new传递一个**标准库对象**nothrow，就不会报错，会返回一个空指针，这种形式的new被称为定位new（placement new）。

bad_alloc 、nothrow都定义在头文件new中。

```cpp
int *p1 = new int;
int *p2 = new(nothrow) int;
```

 

#### 释放动态内存

delete表达式接受一个指针，指向我们要释放的对象，会执行两个动作：

- 销毁给定指针指向的对象
- 释放对应的内存



#### 指针值和delete

传递给delete的指针**必须指向动态分配的内存（new分配的）**，或者一个空指针，**不能重复释放**

const对象同样可以delete指向它的指针来销毁它。

**##一般情况下编译器并不能区分指针指向的是静态的还是动态分配的，也不能区分指针所指的内存是否已经被释放了，编译时一般会通过，尽管他们是错误的**



#### 动态对象的生存期直到被释放为止

#### 空悬指针（dangling pointer）

**delete释放指针后**，指针失效了，但是很多机器上这个指针依然保留着动态地址，这样的指针叫 空悬指针，即，指向一块曾经有效 但现在已经无效的内存 的指针。

#### 小结 使用动态内存非常容易出错

1. 忘记delete内存，也就是常说的“内存泄漏”，因为这种内存“永远”不可能会被还给自由空间了。malloc分配的都是假的，malloc的请求系统都知道，在程序结束后，系统会回收malloc的所有资源
2. 使用已经释放的对象
3. 同一内存释放两次。当多个指针指向相同动态分配的对象时，可能发生。

**best practices：坚持只是用智能指针**



### 3 shared_ptr和new结合使用

 1. 可以使用new返回的指针初始化智能指针

 2. 智能指针**接受指针参数**，构造函数是**explicit的**，不能将内置指针隐式的转换为智能指针，**必须使用直接初始化**
    ```cpp
    shared_ptr<int> p1 = new int(42); //错误，不能隐式转换
    shared_ptr<int>p1(new int(42)); //正确，直接初始化
    ```
|表达式 | 语法|
|--- | --- |
| shared_ptr<T> p(q) | p管理内置指针q所指的对象；q必须指向new分配的内存，并且能够转换为T* |
| shared_ptr<T> p(u) | p从unique_ptr u那里接管对象的所有权；将u置为空 |
| shared_ptr<T> p(q, d) | p 将调用 d 来替代delete |
|  shared_ptr<T> p(p2, d) | p 是p2的拷贝  |
| p.reset()| 若p是唯一指向其对象的智能指针，reset会释放此对象，将p置空|
|p.reset(q)|令p指向q，delete释放q|
|p.reset(q, d)|还会调用d替代delete释放q|



#### 不用混合使用智能指针和普通指针

体会下面的例子

~~~cpp
void process(shared_ptr<int> p1) {
    ...//使用p1
}//p1离开作用域，p1被销毁
~~~

正确的用法

~~~cpp
shared_ptr<int> p2(new int(42));//计数加一，为1
process(p2);//拷贝，计数加一，为2
//计数减一，为1  
int i = *p2;//引用计数为1

~~~

错误例子

```cpp
int *x(new int(42));
process(s); //错误，不能隐式转化
process(shared_ptr<int>(x));//正确，但是x的内存会被释放 
int i = *x;//错误，x是空悬指针
```

将一个shared_ptr与一个普通指针绑定之后，就将这块**内存的管理权限交给了shared_ptr**,一旦这样做了，就**不能再使用普通指针来访问这块内存了**，因为编译器不知道它什么时候被销毁。







