# 动态内存

## 1 动态内存与智能指针

​	new：在动态内存中为对象分配空间并返回一个指向该对象的指针

​	delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存

**新标准库提供两种智能指针：** 和常规指针的区别是能**自动释放所指对象**

 这两者的区别是：

​	**shared_ptr** 允许对各指针指向同一个对象

​	**unique_ptr** 独占所指对象

**weak_ptr**伴随类，弱引用，指向shared_ptr所管理的对象

> 都定义在 memory头文件



### shared_ptr类

#### 创建智能指针

1. 必须指出可以指向的类型
2. 命名 shared_ptr<T> p1;
3. 默认初始化是空指针     

#### 使用

1. 解引用返回所指对象
2. 在判断条件中，检测为空；有指向，则为true
3. p>get() 返回保存的指针，如果释放的对象，返回的对象消失
4.  swap(p, q)    p.swap(q)  
5. make_shared<T>(args)   返回一个shared_ptr，指向动态分配的类型为T的对象。使用args初始化   //独有
6. shared_ptr<T> p (q)   p是q的拷贝，会**增加q**中的**计数器**   //独有
7. p = q 都是shared，保存的指针能互相转换，会**递减p**的引用计数，若p的引用计数变为0，**将原内存释放** //独有

####  make_shared 最安全的分配使用动态内存方法

定义在memory头文件中

根据args构造对象，不传参数按照值初始化

**每个shared_ptr都有一个关联计数器，称为 引用计数，只要拷贝一个shared，计数器都会递增，赋予一个新的值或者被销毁（例如离开作用域）会递减，一旦计数器变为0，就会自动释放自己管理的对象**

>  tip：不是指针被释放，是指针所指对象被释放（因为已经不被引用了）



#### 自动销毁所管理的对象

​	当指向一个对象的最后一个shared被销毁时，shared类会通过析构函数自动销毁此对象。

​	note：如果将shared放入一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不在需要的那些元素



#### 使用了生态生存期的资源的类

​	程序使用动态内存的原因：

1. 程序不知道自己需要多少对象 （容器类）
2. 程序不知道所需对象的准确类型
3. 程序需要在多个对象之间共享数据
   1. 一般而言，如果两个对象共享底层数据，当某个对象被销毁时，不能单方面销毁底层数据



### 直接管理内存 new、 delete

在学习拷贝之前，除非使用智能指针来管理内存，否则不要分配动态内存。

















